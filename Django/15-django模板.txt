csrf（跨站攻击）:
	取消csrf验证,只有请求方式是POST才需要
		注释中间件,在settings文件中的MIDDLEWARE_CLASSES ,找到含有csrf的一行,将其注释
		但是直接注释等于关闭掉了验证,不安全
		使用如下方法:
			在表单的开头标签下面写上 {% csrf %}
模板中引入静态文件:
	{% load staticfile %}

django模板中的语言称为 : 
	简称DTL
		输出变量:{{ 变量 }}
		语法: {% for i in xx %}

			{{ forloop.counter }} -- 可以得到当前循环是第几次
			
			{% if .. %}	
			    逻辑1
			{% elif .. %}		
			    逻辑2
			{% else %}		
			    逻辑3
			{% endif .. %}
			    结尾
		
			{% empty %}  --如果循环的对象空的就走这

		      {% endfor %}  --结尾
		
		过滤器（基本是运算）太多,用的时候网上查

			语法：
				{% 变量|过滤器 %}
					例如 : 变量|divisibleby:'2'  整除2
				
		过滤器串联:
			变量|过滤器1|过滤器2			
		
		注释
			{# 单行注释 #}			

			{% comment %}	
			    多行注释
			{% endcomment %}	

		反向解析
			好处:
				变更url后,不需要更改对应链接的的属性了,因为链接属性在定义的时候就自动生成了与url相匹配的地址
			例如: href = {% url 'app:show' '指定传给url的参数,可以多写或不写' %}

			父url起别名 include第三个参数,namespace='',为了区分应用

			子url: name = ''
			
		模板继承
			block标签,在父模版中预留一个区域,让子模版来继承(挖坑),
				{% block 坑名%}
				预留的区域
				{% endblock 坑名  %}

			extends，在子模版中继承 
				{% extends '继承于的模板' %}

				继承父模版中预留的区域（填父模板的坑)(子模板中的内容必须写在坑中)
				{% block 坑名 %}
					子模版需要写的内容
				{% endblock 坑名  %}	
			
			传参
				在子模版的视图函数中传入参数在祖先模板中也可以使用						

			三层模板继承			
				在主模板base中写好html代码,挖一个坑,在base_user中继承base,填base中的坑,然后再挖一个坑,
				写一个user1和user2来继承base_user,并且填base_user中的坑
				
				可以跨层填坑: 子模板可以填祖先模板挖的坑

		html转义
		     django默认转义,可以有办法来设置不转义
			如果在上下文中传递html代码,django会自动转移成其他的字符,会转义的字符(< > ' " &)
			可以在变量后加个safe过滤器,就等于关闭了转移,django会将他识别为html代码执行
			或者将不需要转义的代码写在{% aotuescape off %}{% endautoescape %}标签中
			
			在模板中定义的变量默认不转义 ，定义变量(使用过滤器) : {% 变量名|default: '...' %}
				想转义就要手动转义

内存文件的操作	
	导入cStringIO模块
	验证码
		安装pillow
		利用PIL绘制验证码
			1.创建背景色
			2.创建画布,
			3.构造字体对象
			4.创建画笔
			5.创建文本内容,字体
			6.绘制逐个字符(循环)
				将每个随机绘入的字符保存在一个定义的空字符中
			7.存入seesion保存的字符,用于验证
			8.保存到内存流中,需要使用cstringIO
			9.返回response对象  return HttpResponse(缓存IO对象,'图片/保存在IO中的格式')
			10.新建一个表单视图网页,action写成另一个试图
			11.在另一个视图中接收表单中的输入值,并与session中的字符做比较
				
调用对象的方法或者属性:
	在views文件中实例化一个模型类的对象,然后传入上下问对象给模板,模板则可以直接调用该对象的属性或方法
